{"pages":[],"posts":[{"title":"马超然","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/17/hello-world/"},{"title":"Linked List链表","text":"About Linked List 关于链表29st May 2019 Wednesday 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;using namespace std;typedef struct node { int date; struct node *nexd;}onenode;onenode *crate_node(int n){ onenode *Link = (onenode*)malloc(sizeof(onenode)); //Link = (onenode*)malloc(sizeof(onenode)); if (Link == NULL) { puts(&quot;申请内存失败：&quot;); return NULL; } memset(Link, 0, sizeof(onenode)); Link-&gt;date = n; Link-&gt;nexd=NULL; return Link;}// 尾插void tail_inster(onenode *heat, onenode *thenew){ onenode *t = heat; //一直向后推。直到推到最后一个 while (t-&gt;nexd != NULL) { t = t-&gt;nexd; } t-&gt;nexd = thenew;}//头插void topinster(onenode *header, onenode *nex) { onenode *h = header; nex-&gt;nexd = h-&gt;nexd; h-&gt;nexd = nex;}//历遍void prin(onenode *head) { onenode *h = head; h = h-&gt;nexd; while (NULL != h-&gt;nexd) { cout &lt;&lt;&quot;data：&quot;&lt;&lt; h-&gt;date&lt;&lt;endl; h = h-&gt;nexd; } cout &lt;&lt; h-&gt;date;}int detele_list(onenode *head, int date) { onenode *h = head; onenode *prev = NULL; while (h-&gt;nexd != NULL) { prev = h; //保存当前节点前一个节点的指针； h = h-&gt;nexd; if (h-&gt;date == date) { //两种情况一种是尾结点，另一种不是 if (h-&gt;date != NULL) { prev-&gt;nexd = h-&gt;nexd; free(h); } else { prev-&gt;nexd = NULL; free(h); } return 0; } } puts(&quot;没有要删除的节点&quot;); return -1;}void trave_list(onenode *head) { onenode *h; h = head-&gt;nexd; onenode *pbck; int i = 0; if (h-&gt;nexd == NULL || h == NULL) return; while (h-&gt;nexd != NULL) { pbck = h-&gt;nexd; if (h == head-&gt;nexd) { h-&gt;nexd = NULL; } else { h-&gt;nexd = head-&gt;nexd; } head-&gt;nexd = h; h = pbck; } topinster(head, h); char a;}int main(){ int i; onenode *head = crate_node(0); for (i = 1; i &lt; 5; i++) { //head是地址每次都在变 tail_inster(head, crate_node(i)); } prin(head); detele_list(head, 2); putchar(&apos;\\n&apos;); prin(head); putchar(&apos;\\n&apos;); trave_list(head); putchar(&apos;\\n&apos;); prin(head); return 0;}","link":"/2019/05/29/Data-Structure/"},{"title":"test","text":"所有测试在此进行All tests will be done here :&gt; 参考文献12codes test#include 分割线dividers 列表 1 2 1 2 连接test 11 11 11 111","link":"/2019/05/17/test/"}],"tags":[{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"test","slug":"test","link":"/tags/test/"}],"categories":[{"name":"Linked List","slug":"Linked-List","link":"/categories/Linked-List/"},{"name":"test1","slug":"test1","link":"/categories/test1/"}]}