{"pages":[],"posts":[{"title":"DOSBOX汇编指令","text":"DOSBOX汇编指令 1234567891011121314MASM test.ASMlink test.objtest.exedebug -u 我们看到的是机器指令 和 汇编指令debug -d 看到 数据-r 查看CPU中所有寄存器的状态-r ax 修改寄存器的内容-d 内存地址 内存地址内容 ascii编码-u 从一个位置的机器码翻译成汇编指令","link":"/2019/10/09/DOSBOX汇编指令/"},{"title":"leetcode 找到所有数组中消失的数字","text":"用了哈希表遍历 胜之不武日后在琢磨别的算法这里先mark一下","link":"/2020/03/25/leetcode-找到所有数组中消失的数字/"},{"title":"马超然","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/17/hello-world/"},{"title":"如何把本地文件推到github","text":"如何把本地文件推到githubHow to push my files to github不间断更新 找到新加文件的位置 找到本地库库处git add . git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”） git push -u origin master （注：此操作目的是把本地仓库push到github上面","link":"/2019/05/29/skill/"},{"title":"test","text":"所有测试在此进行 参考文献12codes test#include 分割线dividers 列表 1 2 1 2 连接test 11 11 11 111","link":"/2019/05/17/test/"},{"title":"二分法","text":"二分查找法leetcode3512345678910111213141516171819int searchInsert(vector&lt;int&gt;&amp; nums, int target) { // 二分法实现 int left = 0, right = nums.size()-1; int mid = 0; while( right &gt;= left){ mid = (right + left)/2; if( nums[mid] == target ) return mid; else if( nums[mid] &lt; target){ // 二分法灵魂 left = mid + 1; } else{ right = mid - 1; } } // 如果找不到 返回左值即为要插入的地点 return left; }","link":"/2020/03/20/二分法/"},{"title":"Linked List链表","text":"About Linked List 关于链表29st May 2019 Wednesday 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;using namespace std;typedef struct node { int date; struct node *nexd;}onenode;onenode *crate_node(int n){ onenode *Link = (onenode*)malloc(sizeof(onenode)); //Link = (onenode*)malloc(sizeof(onenode)); if (Link == NULL) { puts(&quot;申请内存失败：&quot;); return NULL; } memset(Link, 0, sizeof(onenode)); Link-&gt;date = n; Link-&gt;nexd=NULL; return Link;}// 尾插void tail_inster(onenode *heat, onenode *thenew){ onenode *t = heat; //一直向后推。直到推到最后一个 while (t-&gt;nexd != NULL) { t = t-&gt;nexd; } t-&gt;nexd = thenew;}//头插void topinster(onenode *header, onenode *nex) { onenode *h = header; nex-&gt;nexd = h-&gt;nexd; h-&gt;nexd = nex;}//历遍void prin(onenode *head) { onenode *h = head; h = h-&gt;nexd; while (NULL != h-&gt;nexd) { cout &lt;&lt;&quot;data：&quot;&lt;&lt; h-&gt;date&lt;&lt;endl; h = h-&gt;nexd; } cout &lt;&lt; h-&gt;date;}int detele_list(onenode *head, int date) { onenode *h = head; onenode *prev = NULL; while (h-&gt;nexd != NULL) { prev = h; //保存当前节点前一个节点的指针； h = h-&gt;nexd; if (h-&gt;date == date) { //两种情况一种是尾结点，另一种不是 if (h-&gt;date != NULL) { prev-&gt;nexd = h-&gt;nexd; free(h); } else { prev-&gt;nexd = NULL; free(h); } return 0; } } puts(&quot;没有要删除的节点&quot;); return -1;}void trave_list(onenode *head) { onenode *h; h = head-&gt;nexd; onenode *pbck; int i = 0; if (h-&gt;nexd == NULL || h == NULL) return; while (h-&gt;nexd != NULL) { pbck = h-&gt;nexd; if (h == head-&gt;nexd) { h-&gt;nexd = NULL; } else { h-&gt;nexd = head-&gt;nexd; } head-&gt;nexd = h; h = pbck; } topinster(head, h); char a;}int main(){ int i; onenode *head = crate_node(0); for (i = 1; i &lt; 5; i++) { //head是地址每次都在变 tail_inster(head, crate_node(i)); } prin(head); detele_list(head, 2); putchar(&apos;\\n&apos;); prin(head); putchar(&apos;\\n&apos;); trave_list(head); putchar(&apos;\\n&apos;); prin(head); return 0;}","link":"/2019/05/29/Data-Structure/"},{"title":"leetcode可以用递归写的题","text":"持续更新 递归三部曲： 找到出口 最小化要执行的操作（递归写在此处） return 24 两两交换链表中的节点 100 相同的树 101 对称二叉树 104 二叉树的最大深度 226 反转二叉树","link":"/2020/03/26/leetcode可以用递归写的题/"},{"title":"二分法查找两个元素的和","text":"之前用二分法，查找某个元素，但是今天写leetcode遇到一个题，是使用二分法查找两个元素的和，有些许不同 leetcode167题目主要不同是在一次查找失败后，改变low和high的方式，不再是 high - 1与 low + 1 ,而是low++， high–; 主要是自己的思路太阻塞，过于喜欢生搬硬套12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { // 二分法查找 int low = 0, hight = numbers.size() - 1; int sum = 0; while( low &lt; hight ){ sum = numbers[ low ] + numbers[hight]; if( sum == target){ return { low + 1, hight + 1}; } // 如果小于 目标 hight向右移 if( sum &gt; target){ hight--; }else{ low++; } } return {-1, -1}; }};","link":"/2020/03/23/二分法查找两个元素的和/"},{"title":"vector","text":"vector 初步使用初始化 123456789101112131415// 当不知道有多少元素 vector为空 容器中没有元素vector&lt;int&gt;ilist1;// 拷贝ilist1vector&lt;int&gt;ilist2 = ilist1;// 初始ilist为 一串数值vector&lt;int&gt; ilist{1,2,3,4,5,6,7};// 为3,4,5,6,vector&lt;int&gt;ilist3(ilist.begin()+2, ilist.end()-1);// 默认初始化包含七个元素vector&lt;int&gt;ilist4(7);// 7个值为3的intvector&lt;int&gt;ilist5(7,3);// 这个不大会用 当成二维vector的一种写法vector&lt;int&gt;ilist[100] 123456789二维vector赋值vector&lt;vector&lt;int&gt;&gt; trust {{1,2},{1,2}};cout&lt;&lt;trust[0][0];数组加值vector&lt;int&gt;v;v.push_back( c ); // vector的末尾 添加一个数v.pop_back();","link":"/2020/03/16/从数组到vevtor/"},{"title":"字符串处理","text":"经常用到的 头文件1#include &lt;string&gt; 常见的转换操作 int转string 123to_string()// vs2010得这样写to_string(static_cast&lt;long long&gt;(sum)) string转int 123// 即使是负数也没问题s = \"-123\";atoi( s1.c_str() ); 使用getline注意事项如果在使用getline前，要使用scanf或者cin，先使用一些getchar(),读取换行符","link":"/2020/03/13/字符串处理/"},{"title":"虚拟机没有网络的问题","text":"虚拟机右上方有线网络消失不见，使虚拟机无法上网最后这样得以解决 sudo service network-manager stop sudo rm /var/lib/NetworkManager/NetworkManager.state sudo service network-manager start sudo gedit /etc/NetworkManager/NetworkManager.conf（把false改成true） sudo service network-manager restart","link":"/2020/03/13/拟机没有网络的问题/"},{"title":"kmp算法与改进的kmp算法","text":"kmp算法还不太理解get_next的运行过程 12345678910111213141516171819202122232425262728293031323334353637383940void get_next( string s, int next[] ){ int i = 0; int j = -1; next[0] = -1; while( i &lt; s.size() - 1){ if( j == -1 || s[i] == s[j]){ i++; j++; next[i] = j; } else j = next[j]; } } int strStr(string haystack, string needle) { if( needle == \"\") return 0; /**********kmp***********/ int next[ needle.size() ]; get_next( needle,next ); //cout&lt;&lt;next[0]; int i = 0, j = 0; int len1 = haystack.length(); int len2 = needle.length(); while( i &lt; len1 &amp;&amp; j &lt; len2 ){ if( j == -1 || haystack[i] == needle[j] ){ i++; j++; }else j = next[j]; } // cout&lt;&lt;i; // cout&lt;&lt;needle.size()&lt;&lt;endl; if(j &gt;= len2 ) return i - len2 ; else return -1; }}; 改进的kmp算法 123456789101112131415161718192021222324252627282930313233343536373839404142// 改进的kpm算法 void get_nextval( string s, int nextval[] ){ int i = 0; int j = -1; nextval[0] = -1; while( i &lt; s.size() - 1){ if( j == -1 || s[i] == s[j]){ i++; j++; if( s[i] != s[j]) nextval[i] = j; else nextval[i] = nextval[j]; } else j = nextval[j]; } } int strStr(string haystack, string needle) { if( needle == \"\") return 0; /**********kmp***********/ int nextval[ needle.size() ]; get_nextval( needle,nextval ); //cout&lt;&lt;next[0]; int i = 0, j = 0; int len1 = haystack.length(); int len2 = needle.length(); while( i &lt; len1 &amp;&amp; j &lt; len2 ){ if( j == -1 || haystack[i] == needle[j] ){ i++; j++; }else j = nextval[j]; } // cout&lt;&lt;i; // cout&lt;&lt;needle.size()&lt;&lt;endl; if(j &gt;= len2 ) return i - len2 ; else return -1; }","link":"/2020/03/21/kmp算法/"},{"title":"二叉树的历遍","text":"把他分为四大种 同时在leetcode的二叉树的前序遍历,二叉树的中序遍历,二叉树的后序遍历 进行验证 目录特别注意 在写迭代算法时候，参考了严蔚敏书上的算法，在c++书写上，有一点要注意，严书实现栈的pop( S, p),同时p改变了，使p指向了出栈的元素，使用c++时候应该注意。 前序遍历 递归写法 迭代写法 中序遍历 递归写法 迭代写法 后序列遍历 递归写法 迭代写法 层序历遍 使用队列的层次历遍 前序历遍根左右 前序历遍的递归写法因为较为简单，不在写思路12345678910void dfs( TreeNode *root){ if( root == NULL) return; else{ vct.push_back( root-&gt;val ); preorderTraversal( root-&gt;left ); preorderTraversal( root-&gt;right ); }} 前序历遍的迭代写法 1， 当有左子树可以访问时候，储存到vector中（访问之），并压入栈中 2， 当无左子树可以访问时候，弹出栈顶元素，并向右子树走 3， 继执行1 123456789101112131415161718192021222324252627vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt;ans; if( root == NULL ) return ans; TreeNode *p = root; stack&lt; TreeNode *&gt;stk; while( p || !stk.empty() ){ if( p ){ // 一路向左 // 先入栈 stk.push( p ); int tmep = stk.top()-&gt;val; ans.push_back( tmep ); p = p-&gt;left; } else{ //出栈转向右子树 // 栈顶元素出栈 p = stk.top(); stk.pop(); p = p-&gt;right; } } return ans; } 中序遍历左根右 中序历遍的递归写法1234567891011121314vector&lt;int&gt; ans; void dfs( TreeNode *root){ if( root == NULL){ return; }else{ dfs( root-&gt;left); ans.push_back( root-&gt;val); dfs( root-&gt;right ); } } vector&lt;int&gt; inorderTraversal(TreeNode* root) { dfs( root ); return ans; } 中序历遍的迭代写法思路 1， 遇到一个节点，把它压倒栈中，并去历遍他的左子树 2， 当左子树历遍结束后，从栈中弹出这个节点，并访问它 3， 然后按其他右指针再去中序遍历该节点的右子树 1234567891011121314151617181920212223vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt;ans; if( root == NULL ) return ans; TreeNode *p = root; stack&lt; TreeNode *&gt;stk; while( p || !stk.empty() ){ if( p ){ stk.push( p ); p = p-&gt;left; }else{ int tmep = stk.top()-&gt;val; ans.push_back( tmep ); p = stk.top(); stk.pop(); // 改变p的指向 p = p-&gt;right; } } return ans; } 后序历遍左右跟 后序历遍的递归写法后序历遍的迭代写法","link":"/2020/03/27/二叉树的历遍/"},{"title":"旋转数组","text":"给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。用暴力法，一次挪一个会超时在讨论区学到了一个较为简单的算法用翻转法 分为三步 [1,2,3,4,5,6,7] 和 k = 3 1,反转全部 [7,6,5,4,3,2,1] 2,反转前k个 变成[5,6,7,4,3,2,1] 3,反转后k之后的 变成 [5,6,7,1,2,3,4]123456789void rotate(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); k %= len; if( len &lt; 2) return; reverse( nums.begin(), nums.end() ); reverse( nums.begin(), nums.end() - ( len - k)); reverse( nums.begin() + k, nums.end() ); }","link":"/2020/03/24/旋转数组/"},{"title":"根据入栈顺序判断出栈顺序对错","text":"根据入栈顺序判断出栈顺序对错 参考了CSDN这篇文章 在pat甲的1051采用了此算法1234567891011121314151617// 根据入栈顺序判断出栈顺序对错bool isTrue(vector&lt;int&gt; pushv, vector&lt;int&gt; popv) { if (pushv.empty()) return false; stack&lt;int&gt; temp; for (int i = 0, j = 0; i &lt; pushv.size(); i++) { // 入栈 temp.push(pushv[i]); while ( !temp.empty() &amp;&amp; j &lt; popv.size() &amp;&amp; temp.top() == popv[j]) { temp.pop(); j++; } } return temp.empty();}","link":"/2020/03/16/根据入栈顺序判断出栈顺序对错/"},{"title":"PAT里不会的单词","text":"单词 英语 中文 modify 修改 compute 计算， 估算 capital English letter 英语大写字母 case sensitive 区分大小写 first two 前两个 notorious 臭名昭著的 sentence 句子 particles 微粒，粒子 distinct 独特的，明显的，有区别的 Radix 进制","link":"/2020/02/05/单词/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"二分法","slug":"二分法","link":"/tags/二分法/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/虚拟机/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"树","slug":"树","link":"/tags/树/"},{"name":"旋转数组","slug":"旋转数组","link":"/tags/旋转数组/"},{"name":"栈","slug":"栈","link":"/tags/栈/"}],"categories":[{"name":"HOW","slug":"HOW","link":"/categories/HOW/"},{"name":"test1","slug":"test1","link":"/categories/test1/"},{"name":"coding","slug":"coding","link":"/categories/coding/"}]}